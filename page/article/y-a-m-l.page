---
title: YAML Parser
description: YAML-like string parser.
...

To store array in [YAML](http://www.yaml.org "YAML Ain’t Markup Language (YAML™)") format or to convert YAML-like data format into array is possible with Mecha but it is limited only to `key: value`-based syntax to mimic array keys and their values. This means that you can’t parse external YAML files anyway with Mecha’s internal string parser, but the YAML-like data generated by `To::YAML()` method basically can be treated as a valid YAML data in most cases.

### Converter

#### String to Array

~~~ .php
$test = From::YAML('foo: bar');
~~~

[connect:../reference/class/from]

#### Array to String

~~~ .php
$test = To::YAML(['foo' => 'bar']);
~~~

[connect:../reference/class/to]

### Syntax

#### Key and Value

~~~ .yaml
foo: bar
baz: qux
~~~

~~~ .json
{
  "foo": "bar",
  "baz": "qux"
}
~~~

#### Empty Value

~~~ .yaml
foo:
bar: ''
baz: ""
~~~

~~~ .json
{
  "foo": [],
  "bar": "",
  "baz": ""
}
~~~

#### Empty Data

~~~ .yaml

~~~

~~~ .json
[]
~~~

#### Comments

~~~ .yaml
# comment
test_1: foo
test_2: foo # comment
test_3: 'foo # comment' # comment
test_4: "foo # comment" # comment
test_5: # comment 'foo'
test_6: # comment "foo"
~~~

~~~ .json
{
  "test_1": "foo",
  "test_2": "foo",
  "test_3": "foo # comment",
  "test_4": "foo # comment",
  "test_5": [],
  "test_6": []
}
~~~

#### Sequential Array

Arrays with numeric keys.

##### Manual

~~~ .yaml
0: a
1: b
2: c
~~~

~~~ .json
["a", "b", "c"]
~~~

##### Automatic

~~~ .yaml
- a
- b
- c
~~~

~~~ .json
["a", "b", "c"]
~~~

#### Compact Array

~~~ .yaml
foo: [bar, baz, 0, true]
bar: { baz: qux }
~~~

~~~ .json
{
  "foo": ["bar", "baz", 0, true],
  "bar": {
    "baz": "qux"
  }
}
~~~

#### Data Type

All data types will be converted automatically by the [`e`][link:../reference/function#reference:e].

~~~ .yaml
string: a
integer: 1
float: 1.5
boolean: true
null: null
"YAML's null": ~
JSON: {"foo":"bar","baz":"qux","string_integer":"1","string_boolean":"false"}
string_integer: "1"
string_float: "1.5"
string_boolean: "true"
string_null: "null"
single_quote: 'foo\nbar'
double_quote: "foo\nbar"
~~~

~~~ .json
{
  "string": "a",
  "integer": 1,
  "float": 1.5,
  "boolean": true,
  "null": null,
  "YAML's null": null,
  "JSON": {
    "foo": "bar",
    "baz": "qux",
    "string_integer": "1",
    "string_boolean": "false"
  },
  "string_integer": "1",
  "string_float": "1.5",
  "string_boolean": "true",
  "string_null": "null",
  "single_quote": "foo\\nbar",
  "double_quote": "foo\nbar"
}
~~~

~~~ .php
[
    'string' => 'a',
    'integer' => 1,
    'float' => 1.5,
    'boolean' => true,
    'null' => null,
    'YAML\'s null' => null,
    'JSON' => stdClass::__set_state([
        'foo' => 'bar',
        'baz' => 'qux',
        'integer' => 1,
        'boolean' => false
    ]),
    'string_integer' => '1',
    'string_float' => '1.5',
    'string_boolean' => 'true',
    'string_null' => 'null',
    'single_quote' => 'foo\nbar',
    'double_quote' => 'foo
bar'
]
~~~

#### Nesting

~~~ .yaml
a: b
c: d
e:
  f: g
  h: i
j: k
~~~

~~~ .json
{
  "a": "b",
  "c": "d",
  "e": {
    "f": "g",
    "h": "i"
  },
  "j": "k"
}
~~~

#### Escaping

~~~ .yaml
foo\: bar: baz
foo: bar: baz
~~~

~~~ .json
{
  "foo: bar": "baz",
  "foo": "bar: baz"
}
~~~

~~~ .yaml
"foo: bar": baz
foo: bar: baz
~~~

~~~ .json
{
  "foo: bar": "baz",
  "foo": "bar: baz"
}
~~~

~~~ .yaml
'foo: bar': baz
foo: bar: baz
~~~

~~~ .json
{
  "foo: bar": "baz",
  "foo": "bar: baz"
}
~~~

#### Block

~~~ .yaml
'folded block': >
  lorem ipsum
  dolor sit amet
    a b c
'literal block': |
  lorem ipsum
  dolor sit amet
    a b c
~~~

~~~ .json
{
  "folded block": "lorem ipsum dolor sit amet\n  a b c",
  "literal block": "lorem ipsum\ndolor sit amet\n  a b c"
}
~~~