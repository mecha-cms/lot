---
title: `__callStatic()`
description: Dynamic methods.
...

Hooks storage will group your assets data based on its file extension. When you do `Asset::set('foo.css')` and `Asset::set('bar.css')` for example, actually, you are just doing this internally:

~~~ .php
Asset::$lot = [
    'css' => [
        1 => [
            'foo.css' => [
                'path' => '.\www\lot\asset\foo.css',
                'url' => '%{url}%/lot/asset/foo.css',
                'id' => 'foo.css',
                'stack' => 10
            ],
            'bar.css' => [
                'path' => '.\www\lot\asset\bar.css',
                'url' => '%{url}%/lot/asset/bar.css',
                'id' => 'bar.css',
                'stack' => 10
            ]
        ]
    ]
];
~~~

Calling the `Asset` class followed by the file extension will return a merged version of the file contents that are generated by reading all of the available valid `path` data. Other than that, the results will depend on [`Asset::_()`][link:_] method definition related to the file extension. For example, all files with extension `js` will return list of HTML `<script>` tags with `url` data as the `src` attribute value:

~~~ .php
echo Asset::css();
~~~

~~~ .php
echo Asset::js();
~~~

~~~ .php
echo Asset::json(); // not yet defined by `Asset::_()`, calling this will return the file content
~~~

Calling a single asset path:

~~~ .php
echo Asset::css('style-2.css'); // → return `<link href=" … /style-2.css" rel="stylesheet">`
~~~

~~~ .php
echo Asset::js('script-1.js', [
    'type' => 'text/javascript'
]); // → return `<script src=" … /script-1.css" type="text/javascript"></script>`
~~~