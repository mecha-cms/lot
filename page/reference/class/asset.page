---
title: Class `Asset`
description: Asset hooks.
...

> **Info:** This class is located in `lot\extend\asset\engine\kernel` folder.

### Path

~~~ .xmp.php
Asset::path($path, $fail = false);
~~~

Generate full private file path of the `$path`. First of all, this method will find out whether there is a `style.css` file relative to the asset directory of the current shield folder, if it does not exist, then this method will find out whether there is a `style.css` file relative to the main asset directory that is located in `lot\asset`. If none was found, then this method will return `$fail`:

~~~ .php
$path = Asset::path('style.css');
~~~

> **Note:** Setting external URL to the `$path` parameter will return to `$fail`.

### URL

~~~ .xmp.php
Asset::url($path, $fail = false);
~~~

Generate full public URL path of the `$path`. First of all, this method will run the `Asset::path()` method to determine whether the file is exists. If it does exist, then the returned file path will be converted into public URL path, otherwise, this method will return `$fail` for relative URL path or `$path` for external URL:

~~~ .php
$path = Asset::url('style.css');
~~~

> **Note:** Setting external URL to the `$path` parameter will return that `$path` anyway.

### Set

~~~ .xmp.php
Asset::set($path, $stack = null);
~~~

Append `style-2.css` file to the hooks storage:

~~~ .php
Asset::set('style-2.css');
~~~

Make sure to put `style-3.css` before `style-2.css` in the output:

~~~ .php
Asset::set('style-3.css', 9);
~~~

> **Note:** Default `$stack` value is `10`.

### Get

~~~ .xmp.php
Asset::get($path, $fail = false);
~~~

Get data of `style-2.css` path that has been added to the hooks storage if any, otherwise, return `$fail`:

~~~ .php
$test_1 = Asset::get('style-2.css');
$test_2 = Asset::get('style-4.css');
~~~

Result:

~~~ .php
$test_1 = [
    'path' => '.\www\lot\asset\style-2.css',
    'url' => '[[url]]/lot/asset/style-2.css',
    'id' => 'style-2.css',
    'stack' => 10
];
~~~

~~~ .php
$test_2 = false;
~~~

Inspect all of the assets data that has been added to the hooks storage:

~~~ .php
__test__(Asset::get());
~~~

### Reset

~~~ .xmp.php
Asset::reset($path = null);
~~~

Remove `asset-2.css` from the hooks storage:

~~~ .php
Asset::reset('style-2.css');
~~~

### Call Static

The hooks storage simply group your assets data based on its file extension. When you do `Asset::set('foo.css')` and `Asset::set('bar.css')` for example, actually, you are doing these internally:

~~~ .php
Asset::$lot = [
    'css' => [
        1 => [
            'foo.css' => [
                'path' => '.\www\lot\asset\foo.css',
                'url' => '[[url]]/lot/asset/foo.css',
                'id' => 'foo.css',
                'stack' => 10
            ],
            'bar.css' => [
                'path' => '.\www\lot\asset\bar.css',
                'url' => '[[url]]/lot/asset/bar.css',
                'id' => 'bar.css',
                'stack' => 10
            ]
        ]
    ]
];
~~~

Calling the `Asset` class followed by the file extension will return a merged version of the file contents that are generated by reading all of the available valid `path` data. Other than that, the results will depend on [`Asset\Union`][link:asset/union] method definition related to the file extension. For example, all files with extension `js` will return list of HTML `<script>` tags with `url` data as the `src` attribute value:

~~~ .php
echo Asset::css();
~~~

~~~ .php
echo Asset::js();
~~~

~~~ .php
echo Asset::json(); // not yet defined by `Asset\Union`, calling this will return the file content
~~~

Calling a single asset path:

~~~ .php
echo Asset::css('style-2.css'); // → return `<link href=" … /style-2.css" rel="stylesheet">`
~~~

~~~ .php
echo Asset::js('script-1.js', [
    'type' => 'text/javascript'
]); // → return `<script src=" … /script-1.css" type="text/javascript"></script>`
~~~

[connect:../extension/asset]