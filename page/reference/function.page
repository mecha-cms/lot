---
title: Function
description: Helper functions.
...

### Test

~~~ .xmp.php
__test__($a[, $b[, $c[, ...]]]);
~~~

Dump a PHP code to show the results:

~~~ .php
__test__($foo, $bar, $baz);
~~~

### Format

~~~ .xmp.php
__format__($s, $x = "\n", $d = '#', $r = true);
~~~

Create regular expression pattern from a string contains some [wildcards](https://en.wikipedia.org/wiki/Wildcard_character "Wildcard Characters – Wikipedia"):

~~~ .php
$pattern = __format__('lorem %s% ipsum %i% dolor # sit amet');
~~~

Parameter | Description
--------- | -----------
`$s` | The string input.
`$x` | Forbidden characters for the `%s%` wildcard.
`$d` | The regular expression delimiter to escape.
`$r` | Can the wildcard be replaced by an empty data?

Pattern | Description
------- | -----------
`%s%` | Accept any string but `$x`.
`%i%` | Accept any string numbers.
`%f%` | Accept any string numbers and floats.
`%b%` | Accept any string booleans.
`%*%` | Accept any string and `$x`.
`%[foo,bar,baz\,qux]%` | Accept `foo`, `bar` and `baz,qux`.
`%[foo,bar,%i%]%` | Accept `foo`, `bar` and any string numbers.

This function will return a regular expression string without the delimiters:

~~~ .php
$pattern = 'lorem ([^\n]+) ipsum (\d+) dolor \# sit amet';
~~~

### Replace

~~~ .xmp.php
__replace__($s, $x = "\n", $r = true);
~~~

TODO

### Is Anemon

~~~ .xmp.php
__is_anemon__($x, $t = null);
~~~

Return `true` if `$x` is array or object.

### Is Numeric Anemon

~~~ .xmp.php
__is_anemon__($x, 0);
~~~

~~~ .xmp.php
__is_anemon_0__($x);
~~~

Return `true` if the encoded JSON version of `$x` starts with `[` and ends with `]` (a JavaScript array).

### Is Associative Anemon

~~~ .xmp.php
__is_anemon__($x, 'a');
~~~

~~~ .xmp.php
__is_anemon_a__($x);
~~~

Return `true` if the encoded JSON version of `$x` starts with `{` and ends with `}` (a JavaScript object).

### Is Instance

~~~ .xmp.php
__is_instance__($x);
~~~

Return the instance if `$x` is an instance of _any_ classes.

### Is JSON

~~~ .xmp.php
__is_json__($x);
~~~

Return `true` if `$x` is a JSON string.

### Is Serial

~~~ .xmp.php
__is_serial__($x);
~~~

Return `true` if `$x` is a serialized string.

### Class to File

~~~ .xmp.php
__c2f__($x, $s = '-', $n = '.');
~~~

Convert class name into file name:

~~~ .php
$test = __c2f__('Foo\Bar\BazQux\Abc\ABC');
~~~

Result:

~~~ .php
$test = 'foo.bar.baz-qux.abc.a-b-c';
~~~

### File to Class

~~~ .xmp.php
__f2c__($x, $s = '-', $n = '.');
~~~

Convert file name into class name:

~~~ .php
$test = __f2c__('foo.bar.baz-qux.abc.a-b-c');
~~~

Result:

~~~ .php
$test = 'Foo\Bar\BazQux\Abc\ABC';
~~~

### Others

#### Array {#reference:a}

~~~ .xmp.php
a($o, $safe = true);
~~~

Convert object to array:

~~~ .php
$test = new stdClass;
$test->a = 'b';
$test->c = new Date;
$test->d = (object) [
    'year' => 0,
    'month' => 0,
    'day' => 0
];

$test = a($test);
~~~

Result:

~~~ .php
$test = [
    'a' => 'b',
    'c' => Date::__set_state([
        'date' => '2016-12-25 23:11:16'
    ]),
    'd' => [
        'year' => 0,
        'month' => 0,
        'day' => 0
    ]
];
~~~

> **Note:** Class instance will not be converted into array if `$safe` is set to `true`.

#### Between {#reference:b}

~~~ .xmp.php
b($x, $a = 0, $b = null);
~~~

Keep value between `$a` and `$b`:

~~~ .php
$a = 0;
$b = 100;

__test__(
    b(4, $a, $b),
    b(-4, $a, $b)
    b(104, $a, $b)
);
~~~

Result:

~~~ .php
4

0

100
~~~

#### Camel Case {#reference:c}

~~~ .xmp.php
c($x, $a = false, $i = "");
~~~

Convert text to `camelCase`:

~~~ .php
$test = c('foo bar a b c');
~~~

Result:

~~~ .php
$test = 'fooBarABC';
~~~

#### Declare {#reference:d}

~~~ .xmp.php
d($f, $fn = null, $s__ = []);
~~~

Declare classes with callback:

~~~ .php
 
~~~

#### Evaluate {#reference:e}

~~~ .xmp.php
e($s, $x = []);
~~~

Evaluate string data to their appropriate data type:

~~~ .php
$test_1 = e('true');
$test_2 = e([
    'true',
    'false',
    'null',
    '1',
    '1.5',
    'a',
    '"true"',
    '"false"',
    '"null"',
    '"1"',
    '"1.5"',
    '{"foo":1,"bar":"1"}'
]);
~~~

Result:

~~~ .php
$test_1 = true;

$test_2 = [
    true,
    false,
    null,
    1,
    1.5,
    'a',
    'true',
    'false',
    'null',
    '1',
    '1.5',
    stdClass::__set_state([
        'foo' => 1,
        'bar' => '1'
    ])
];
~~~

#### Filter {#reference:f}

~~~ .xmp.php
f($x, $a = true, $i = "");
~~~

Filter/sanitize string:

~~~ .php
 
~~~

#### Glob {#reference:g}

~~~ .xmp.php
g($s = ROOT, $x = '*', $q = "", $o = false, $h = true);
~~~

Advance PHP `glob` function:

~~~ .php
$test_1 = g('.\www\path\to\folder');
$test_2 = g('.\www\path\to\folder', 'css');
$test_3 = g('.\www\path\to\folder', 'css,js');
$test_4 = g('.\www\path\to\folder', 'css,js', '.min.');
$test_5 = g('.\www\path\to\folder', 'mecha.min.{css,js}');
~~~

#### Hyphenate {#reference:h}

~~~ .xmp.php
h($x, $h = '-', $a = false, $i = "");
~~~

Convert text to `slug-case` with `-` (hyphen) as the default separator:

~~~ .php
$test = h('foo-bar Foo Bar ABC');
~~~

Result:

~~~ .php
$test = 'foo-bar-foo-bar-a-b-c';
~~~

#### Include {#reference:i}

~~~ .xmp.php
i($a, $b = [], $fn = [null, null], $s__ = []);
~~~

Include files with callback:

~~~ .php
i('.\www\path\to\folder', [
    'file-0.php',
    'file-1.php',
    'file-2.php'
]);
~~~

#### `j` {#reference:j}

_Reserved._

#### `k` {#reference:k}

_Reserved._

#### Lower Case {#reference:l}

~~~ .php.xmp
l($x);
~~~

Convert string into `lower case`:

~~~ .php
$test = l('POKÉMON');
~~~

Result:

~~~ .php
$test = 'pokémon';
~~~

#### `m` {#reference:m}

_Reserved._

#### Normalize {#reference:n}

~~~ .xmp.php
n($x, $t = '    ');
~~~

Convert `\r\n` and `\r` to `\n` and `\t` to 4 spaces:

~~~ .php
n(file_get_contents('.\www\path\to\file.txt'));
~~~

#### Object {#reference:o}

~~~ .xmp.php
o($a, $safe = true);
~~~

Convert array to object:

~~~ .php
$test = o([
    'a' => 'b',
    'c' => 'd',
    'e' => ['f', 'g', 'h', 'i'],
    'j' => [
        0 => 'k',
        1 => 'l',
        '2' => 'm'
    ],
    'n' => [
        0 => 'o',
        1 => 'p',
        'q' => 'r'
    ]
]);
~~~

Result:

~~~ .php
$test = stdClass::__set_state([
    'a' => 'b',
    'c' => 'd',
    'e' => ['f', 'g', 'h', 'i'],
    'j' => ['k', 'l', 'm'],
    'n' => stdClass::__set_state([
        0 => 'o',
        1 => 'p',
        'q' => 'r'
    ])
]);
~~~

> **Note:** Array with numeric keys will not be converted into object if `$safe` is set to `true`.

#### Pascal Case {#reference:p}

~~~ .xmp.php
p($x, $s = "", $X = "");
~~~

Convert text to `PascalCase`:

~~~ .php
$test = p('foo bar a b c');
~~~

Result:

~~~ .php
$test = 'FooBarABC';
~~~

#### Quantity {#reference:q}

~~~ .xmp.php
q($x, $deep = false);
~~~

Quantity counter (length of string, number or [anemon][link:class/anemon]):

~~~ .php
__test__(
    q([0, 1, 2, 3, 4]),
    q(5),
    q('abcde')
);
~~~

#### Require {#reference:r}

~~~ .xmp.php
r($a, $b = [], $fn = [null, null], $s__ = []);
~~~

Require files with callback:

~~~ .php
r('.\www\path\to\folder', [
    'file-0.php',
    'file-1.php',
    'file-2.php'
]);
~~~

#### String {#reference:s}

~~~ .xmp.php
s($x);
~~~

Convert data type to their string format (this is the inverse version of [`e`][link:#reference:e]):

~~~ .php
$test_1 = s(true);
$test_2 = s([
    true,
    false,
    null,
    1,
    1.5,
    .5,
    'a'
]);
~~~

Result:

~~~ .php
$test_1 = 'true';

$test_2 = [
    'true',
    'false',
    'null',
    '1',
    '1.5',
    '0.5',
    'a',
];
~~~

#### Trim {#reference:t}

~~~ .xmp.php
t($x, $o = '"', $c = null);
~~~

Trim string from `??` and `!!` once:

~~~ .php
$test = t('????abc!!!!', '??', '!!');
~~~

Result:

~~~ .php
$test = '??abc!!';
~~~

#### Upper Case {#reference:u}

~~~ .xmp.php
u($x);
~~~

Convert text to `UPPER CASE`:

~~~ .php
$test = u('pokémon');
~~~

Result:

~~~ .php
$test = 'POKÉMON';
~~~

#### Unescape {#reference:v}

~~~ .xmp.php
v($x);
~~~

Unescape characters (this is the inverse version of [`x`][link:#reference:x]):

~~~ .php
 
~~~

#### Word {#reference:w}

~~~ .xmp.php
w($x, $c = [], $n = false);
~~~

Convert any data to plain words:

~~~ .php
 
~~~

#### Escape {#reference:x}

~~~ .xmp.php
x($x, $c = "'", $d = '-+*/=:()[]{}<>^$.?!|\\');
~~~

Escape characters:

~~~ .php
 
~~~

#### Yield {#reference:y}

~~~ .xmp.php
y($x, $a = []);
~~~

Output/yield an echo-based function as normal return-based function:

~~~ .php
$test_1 = y('.\www\path\to\file.php');
$test_2 = y(function() {
    echo 'test value';
});
~~~

#### Zip {#reference:z}

~~~ .xmp.php
z($a, $b = true, $safe = true);
~~~

Export array/object into a compact PHP file:

~~~ .php
$test_1 = z(['a', 'b', true, false]);
$test_2 = z(['a', 'b', true, false], false);
~~~

Result:

~~~ .php
$test_1 = "['a','b',!0,!1]";

$test_2 = "array('a','b',!0,!1)";
~~~